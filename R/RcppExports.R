# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Collapsing boundary functions
#' 
#' @description evaluate diffusion model boundary using the hyperbolic ratio or weibull functions
#'
#' @param t vector; time points to evaluate boundary
#' @param a numeric or vector; initial boundary
#' @param aprime numeric or vector; degree of collapse (weibull only)
#' @param kappa numeric or vector; slope of collapse
#' @param tc numeric or vector; time constant of collapse
#' 
#' @return 
#' column vector with boundary at time t, 
#' or a time point x parameter vector matrix of boundaries 
#' (each column represents a time varying boundary for a given parameter set)
#' 
#' @name bounds
NULL

#' @rdname bounds
#' @export
hyperbolic_ratio_bound <- function(t, a, kappa = 0, tc = .25) {
    .Call('_rddm_hyperbolic_ratio_bound', PACKAGE = 'rddm', t, a, kappa, tc)
}

#' @rdname bounds
#' @export
hyperbolic_ratio_bound_vec <- function(t, a, kappa = 0L, tc = 0L, check_pars = TRUE) {
    .Call('_rddm_hyperbolic_ratio_bound_vec', PACKAGE = 'rddm', t, a, kappa, tc, check_pars)
}

#' @rdname bounds
#' @export
weibull_bound <- function(t, a, aprime = 0, kappa = 1, tc = .25) {
    .Call('_rddm_weibull_bound', PACKAGE = 'rddm', t, a, aprime, kappa, tc)
}

#' @rdname bounds
#' @export
weibull_bound_vec <- function(t, a, aprime = 0L, kappa = 0L, tc = 0L, check_pars = TRUE) {
    .Call('_rddm_weibull_bound_vec', PACKAGE = 'rddm', t, a, aprime, kappa, tc, check_pars)
}

#' Simulate drift diffusion model with fixed or collapsing boundary
#'
#' @param v numeric; drift rate
#' @param a numeric; initial boundary
#' @param t0 numeric; non-decision time
#' @param z numeric; starting point, 0 < z < 1, default = .5
#' @param dc numeric; drift criterion, the zero point of the drift rate (the drift rate v = v + dc); default = 0
#' @param sv numeric; standard deviation of variability in drift rate, sv >= 0, default = 0
#' @param st0 numeric; variability in non-decision time. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz numeric; variability in starting point. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param aprime numeric; degree of collapse, default = 0
#' @param kappa numeric; slope of collapse, default = 0
#' @param tc numeric; time constant of collapse, default = .25
#' @param s numeric; standard deviation in wiener diffusion noise, default = 1
#' @param sv_points integer; number of points to approximate integral over drift rate variability, default = 19
#' @param sz_points integer; number of points to approximate integral over starting point variability, default = 11
#' @param st0_points integer; number of points to approximate integral over non-decision time variability, default = 11
#' @param dt numeric; time step of simulation, default = .01
#' @param max_time numeric; max time of simulation, default = 10
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#' @param n_threads integer; number of threads to run in parallel, default = 1
#' 
#' @return data frame with two columns: response (1 for upper boundary, 0 for lower), and response time
#' 
#' @export
ddm_integral_fpt <- function(v, a, t0, z = .5, dc = 0, sv = 0, sz = 0, st0 = 0, aprime = 0, kappa = 0, tc = .25, s = 1, sv_points = 19, sz_points = 11, st0_points = 11, dt = .01, max_time = 10, bounds = 0L, n_threads = 1L) {
    .Call('_rddm_ddm_integral_fpt', PACKAGE = 'rddm', v, a, t0, z, dc, sv, sz, st0, aprime, kappa, tc, s, sv_points, sz_points, st0_points, dt, max_time, bounds, n_threads)
}

#' Get first passage time distribution of pulse diffusion model by simulating probability mass
#'
#' @param stimulus matrix; stimulus to simulate (row 1 is evidence to upper boundary, row 2 to lower boundary)
#' @param v numeric; drift rate
#' @param a numeric; initial boundary
#' @param t0 numeric; non-decision time
#' @param z numeric; starting point, 0 < z < 1, default = .5
#' @param dc numeric; drift criterion, the zero point of the drift rate (the drift rate v = v + dc); default = 0
#' @param sv numeric; standard deviation of variability in drift rate, sv >= 0, default = 0
#' @param st0 numeric; variability in non-decision time. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz numeric; variability in starting point. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param s numeric; standard deviation in wiener diffusion noise, default = 1
#' @param lambda numeric; O-U process slope
#' @param aprime numeric; degree of collapse, default = 0
#' @param kappa numeric; slope of collapse, default = 0
#' @param tc numeric; time constant of collapse, default = .25
#' @param dt numeric; time step of simulation, default = .001
#' @param dx numeric; size of evidence bins, default = .05
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#'
#' @return data frame with three columns: response (1 for upper boundary, 0 for lower), response time, and evidence
#'
#' @export
pulse_fp_fpt <- function(stimulus, v, a, t0, z = 0.5, dc = 0, sv = 0, st0 = 0, sz = 0, s = 1, lambda = 0, aprime = 0, kappa = 0, tc = .25, dt = .001, dx = .05, bounds = 0L) {
    .Call('_rddm_pulse_fp_fpt', PACKAGE = 'rddm', stimulus, v, a, t0, z, dc, sv, st0, sz, s, lambda, aprime, kappa, tc, dt, dx, bounds)
}

#' Get pulse model likelihood for a given trial
#'
#' @param choice int; decision on trial, 0 for lower boundary, 1 for upper
#' @param rt numeric; response time on trial
#' @param stimulus matrix; stimulus to simulate (row 1 is evidence to upper boundary, row 2 to lower boundary)
#' @param v numeric; drift rate
#' @param a numeric; initial boundary
#' @param t0 numeric; non-decision time
#' @param z numeric; starting point, 0 < z < 1, default = .5
#' @param dc numeric; drift criterion, the zero point of the drift rate (the drift rate v = v + dc); default = 0
#' @param sv numeric; standard deviation of variability in drift rate, sv >= 0, default = 0
#' @param st0 numeric; variability in non-decision time. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz numeric; variability in starting point. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param s numeric; standard deviation in wiener diffusion noise, default = 1
#' @param lambda numeric; O-U process slope
#' @param aprime numeric; degree of collapse, default = 0
#' @param kappa numeric; slope of collapse, default = 0
#' @param tc numeric; time constant of collapse, default = .25
#' @param dt numeric; time step of simulation, default = .001
#' @param dx numeric; size of evidence bins, default = .05
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#'
#' @return probability of choice and rt for trial given pulse model parameters
#'
#' @export
pulse_trial_lik <- function(choice, rt, stimulus, v, a, t0, z = 0.5, dc = 0, sv = 0, st0 = 0, sz = 0, s = 1, lambda = 0, aprime = 0, kappa = 0, tc = .25, dt = .001, dx = .05, bounds = 0L) {
    .Call('_rddm_pulse_trial_lik', PACKAGE = 'rddm', choice, rt, stimulus, v, a, t0, z, dc, sv, st0, sz, s, lambda, aprime, kappa, tc, dt, dx, bounds)
}

#' Get pulse model negative log likelihood for a set of trials
#'
#' @param choice integer; vector of decisions, 0 for lower boundary, 1 for upper
#' @param rt numeric; vector of response times
#' @param stimuli list; list of stimulus matrices
#' @param up_sequence vector of strings; string of 0s, and 1s of stimulus values (0 no evidence, 1 to upper). If down_sequence not specified, (0 to lower, 1 to upper).
#' @param down_sequence vector of strings; string of 0s, and 1s of stimulus values (0 is no evidence, 1 to lower). If not specified, up_sequence is (0 to lower, 1 to upper)
#' @param v numeric; drift rate, either single value or vector for each trial
#' @param a numeric; initial boundary, either single value or vector for each trial
#' @param t0 numeric; non-decision time, either single value or vector for each trial
#' @param z numeric; starting point, , either single value or vector for each trial, 0 < z < 1, default = .5
#' @param dc numeric; drift criterion, the zero point of the drift rate (the drift rate v = v + dc); default = 0
#' @param sv numeric; standard deviation of variability in drift rate, either single value or vector for each trial, sv >= 0, default = 0
#' @param st0 numeric; variability in non-decision time, either single value or vector for each trial. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz numeric; variability in starting point, either single value or vector for each trial. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param s numeric; standard deviation in wiener diffusion noise, either single value or vector for each trial, default = 1
#' @param lambda numeric; O-U process slope, either single value or vector for each trial
#' @param aprime numeric; degree of collapse, either single value or vector for each trial, default = 0
#' @param kappa numeric; slope of collapse, either single value or vector for each trial, default = 0
#' @param tc numeric; time constant of collapse, either single value or vector for each trial, default = .25
#' @param check_pars logical; if True, check that parameters are vectors of the same length as choices and rts. Must be true if providing scalar parameters. default = true
#' @param dt numeric; time step of simulation, default = .002
#' @param dx numeric; size of evidence bins, default = .05
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#' @param n_threads int; number of threads (trials) to run in parallel
#'
#' @return negative log likelihood of all choices and rts given pulse model parameters
#'
#' @export
pulse_nll <- function(choices, rt, stimuli, v, a, t0, z = 0L, dc = 0L, sv = 0L, st0 = 0L, sz = 0L, s = 0L, lambda = 0L, aprime = 0L, kappa = 0L, tc = 0L, check_pars = TRUE, dt = .001, dx = .05, bounds = 0L, n_threads = 1L) {
    .Call('_rddm_pulse_nll', PACKAGE = 'rddm', choices, rt, stimuli, v, a, t0, z, dc, sv, st0, sz, s, lambda, aprime, kappa, tc, check_pars, dt, dx, bounds, n_threads)
}

#' Get predicted behavior from pulse model
#'
#' @param n int; number of predicted samples to take per stimulus
#' @param stimuli list; list of stimulus matrices
#' @param v numeric; drift rate, either single value or vector for each trial
#' @param a numeric; initial boundary, either single value or vector for each trial
#' @param t0 numeric; non-decision time, either single value or vector for each trial
#' @param z numeric; starting point, , either single value or vector for each trial, 0 < z < 1, default = .5
#' @param dc numeric; drift criterion, the zero point of the drift rate (the drift rate v = v + dc); default = 0
#' @param sv numeric; standard deviation of variability in drift rate, either single value or vector for each trial, sv >= 0, default = 0
#' @param st0 numeric; variability in non-decision time, either single value or vector for each trial. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz numeric; variability in starting point, either single value or vector for each trial. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param s numeric; standard deviation in wiener diffusion noise, either single value or vector for each trial, default = 1
#' @param lambda numeric; O-U process slope, either single value or vector for each trial
#' @param aprime numeric; degree of collapse, either single value or vector for each trial, default = 0
#' @param kappa numeric; slope of collapse, either single value or vector for each trial, default = 0
#' @param tc numeric; time constant of collapse, either single value or vector for each trial, default = .25
#' @param check_pars logical; if True, check that parameters are vectors of the same length as choices and rts. Must be true if providing scalar parameters. default = true
#' @param dt numeric; time step of simulation, default = .001
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#' @param n_threads int; number of threads (trials) to run in parallel
#'
#' @return data frame with two columns: response (1 for upper boundary, 0 for lower), response time
#'
#' @export
pulse_predict <- function(n, stimuli, v, a, t0, z = 0L, dc = 0L, sv = 0L, st0 = 0L, sz = 0L, s = 0L, lambda = 0L, aprime = 0L, kappa = 0L, tc = 0L, check_pars = TRUE, dt = .001, dx = .05, bounds = 0L, n_threads = 1L) {
    .Call('_rddm_pulse_predict', PACKAGE = 'rddm', n, stimuli, v, a, t0, z, dc, sv, st0, sz, s, lambda, aprime, kappa, tc, check_pars, dt, dx, bounds, n_threads)
}

#' Get pulse stimulus
#'
#' @description get full pulse stimulus
#'
#' @param stim_seq numeric vector; vecotr of timepoint by timepoint evidence
#' @param dur numeric; duration of pulse, default = .01
#' @param isi numeric; inter-pulse interval, default = .1
#' @param pre_stim numeric; time before pulse within stimulus bin
#' @param dt numeric; timestep for simulation, default = .001
#'
#' @return stimulus train vector
#'
#' @export
pulse_trial_stimulus <- function(stim_seq, dur = 0.01, isi = 0.1, pre_stim = 0, dt = 0.001) {
    .Call('_rddm_pulse_trial_stimulus', PACKAGE = 'rddm', stim_seq, dur, isi, pre_stim, dt)
}

#' Simulate drift diffusion model with fixed or collapsing boundary
#'
#' @param n integer; number of decisions to simulate
#' @param v numeric; drift rate
#' @param a numeric; initial boundary
#' @param t0 numeric; non-decision time
#' @param z numeric; starting point, 0 < z < 1, default = .5
#' @param dc numeric; drift criterion, the zero point of the drift rate (the drift rate v = v + dc); default = 0
#' @param sv numeric; standard deviation of variability in drift rate, sv >= 0, default = 0
#' @param st0 numeric; variability in non-decision time. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz numeric; variability in starting point. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param aprime numeric; degree of collapse, default = 0
#' @param kappa numeric; slope of collapse, default = 0
#' @param tc numeric; time constant of collapse, default = .25
#' @param s numeric; standard deviation in wiener diffusion noise, default = 1
#' @param dt numeric; time step of simulation, default = .001
#' @param max_time numeric; max time of simulation, default = 10
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#' @param n_threads integer; number of threads to run in parallel, default = 1
#' 
#' @return data frame with two columns: response (1 for upper boundary, 0 for lower), and response time
#' 
#' @export
sim_ddm <- function(n, v, a, t0, z = .5, dc = 0, sv = 0, st0 = 0, sz = 0, aprime = 0, kappa = 0, tc = .25, s = 1, dt = .001, max_time = 10, bounds = 0L, n_threads = 1L) {
    .Call('_rddm_sim_ddm', PACKAGE = 'rddm', n, v, a, t0, z, dc, sv, st0, sz, aprime, kappa, tc, s, dt, max_time, bounds, n_threads)
}

#' Simulate drift diffusion model with fixed or collapsing boundary
#'
#' @param v vector; drift rate
#' @param a vector; initial boundary
#' @param t0 vector; non-decision time
#' @param z vector; starting point, 0 < z < 1, default = .5
#' @param dc vector; drift criterion, the zero point of the drift rate (the drift rate v = v + dc); default = 0
#' @param sv vector; standard deviation of variability in drift rate, sv >= 0, default = 0
#' @param st0 vector; variability in non-decision time. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz vector; variability in starting point. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param aprime vector; degree of collapse, default = 0
#' @param kappa vector; slope of collapse, default = 0
#' @param tc vector; time constant of collapse, default = .25
#' @param s numeric; standard deviation in wiener diffusion noise, default = 1
#' @param dt numeric; time step of simulation, default = .001
#' @param max_time numeric; max time of simulation, default = 10
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#' @param check_pars bool; if True (default) check parameter vector lengths and default values
#' @param n_threads integer; number of threads to run in parallel, default = 1
#'
#' @return data frame with two columns: response (1 for upper boundary, 0 for lower), and response time
#'
#' @export
sim_ddm_vec <- function(v, a, t0, z = 0L, dc = 0L, sv = 0L, st0 = 0L, sz = 0L, aprime = 0L, kappa = 0L, tc = 0L, s = 1, dt = .001, max_time = 10, bounds = 0L, check_pars = TRUE, n_threads = 1L) {
    .Call('_rddm_sim_ddm_vec', PACKAGE = 'rddm', v, a, t0, z, dc, sv, st0, sz, aprime, kappa, tc, s, dt, max_time, bounds, check_pars, n_threads)
}

#' Simulate drift diffusion model with fixed or collapsing boundary
#'
#' @param n integer; number of decisions to simulate
#' @param stimulus matrix; stimulus to simulate, 1 or 2 rows X timepoints. If 2 rows, row 1 is evidence to upper boundary, row 2 to lower boundary.
#' @param v numeric; drift rate
#' @param a numeric; initial boundary
#' @param t0 numeric; non-decision time
#' @param z numeric; starting point, 0 < z < 1, default = .5
#' @param dc numeric; drift criterion, upper drift = v, lower drift = v-d
#' @param sv numeric; standard deviation of variability in drift rate, sv >= 0, default = 0
#' @param st0 numeric; variability in non-decision time. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz numeric; variability in starting point. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param s numeric; standard deviation in wiener diffusion noise, default = 1
#' @param lambda numeric; O-U process slope
#' @param aprime numeric; degree of collapse, default = 0
#' @param kappa numeric; slope of collapse, default = 1
#' @param tc numeric; time constant of collapse, default = .25
#' @param dt numeric; time step of simulation, default = .001
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#' @param n_threads integer; number of threads to run in parallel, default = 1
#' 
#' @return data frame with three columns: response (1 for upper boundary, 0 for lower), response time, and evidence
#' 
#' @export
sim_pulse <- function(n, stimulus, v, a, t0, z = .5, dc = 0, sv = 0, st0 = 0, sz = 0, s = 1, lambda = 0, aprime = 0, kappa = 0, tc = .25, dt = .001, bounds = 0L, n_threads = 1L) {
    .Call('_rddm_sim_pulse', PACKAGE = 'rddm', n, stimulus, v, a, t0, z, dc, sv, st0, sz, s, lambda, aprime, kappa, tc, dt, bounds, n_threads)
}

#' Simulate drift diffusion model with fixed or collapsing boundary
#'
#' @param n integer; number of decisions to simulate
#' @param stimulus matrix; stimulus to simulate, 1 or 2 rows X timepoints. If 2 rows, row 1 is evidence to upper boundary, row 2 to lower boundary.
#' @param v numeric vector; drift rate
#' @param a numeric vector; initial boundary
#' @param t0 numeric vector; non-decision time
#' @param z numeric vector; starting point, 0 < z < 1, default = .5
#' @param dc numeric vector; drift criterion, upper drift = v, lower drift = v-d
#' @param sv numeric vector; standard deviation of variability in drift rate, sv >= 0, default = 0
#' @param st0 numeric vector; variability in non-decision time. Uniform from [t0-st0/2, t0+st0/2], 0 < st0 < t0, default = 0
#' @param sz numeric vector; variability in starting point. Uniform from [z-sz/2, z+sz/2], 0 < sz < z, default = 0
#' @param s numeric vector; standard deviation in wiener diffusion noise, default = 1
#' @param lambda numeric vector; O-U process slope
#' @param aprime numeric vector; degree of collapse, default = 0
#' @param kappa numeric vector; slope of collapse, default = 1
#' @param tc numeric vector; time constant of collapse, default = .25
#' @param dt numeric; time step of simulation, default = .001
#' @param bounds int: 0 for fixed, 1 for hyperbolic ratio collapsing bounds, 2 for weibull collapsing bounds
#' @param check_pars bool; if True (default) check parameter vector lengths and default values
#' @param n_threads integer; number of threads to run in parallel, default = 1
#' 
#' @return data frame with three columns: response (1 for upper boundary, 0 for lower), response time, and evidence
#' 
#' @export
sim_pulse_vec <- function(n, stimuli, v, a, t0, z = 0L, dc = 0L, sv = 0L, st0 = 0L, sz = 0L, s = 0L, lambda = 0L, aprime = 0L, kappa = 0L, tc = 0L, dt = .001, bounds = 0L, check_pars = TRUE, n_threads = 1L) {
    .Call('_rddm_sim_pulse_vec', PACKAGE = 'rddm', n, stimuli, v, a, t0, z, dc, sv, st0, sz, s, lambda, aprime, kappa, tc, dt, bounds, check_pars, n_threads)
}

